//! Mutation testing baseline tracking for CI/CD.
//!
//! Tracks mutation scores over time and detects regressions.

use std::collections::HashMap;
use std::fs;
use std::path::Path;

use serde::{Deserialize, Serialize};

use crate::core::{Error, Result};

use super::super::{Analysis, OperatorStats};

/// A stored mutation testing baseline for a specific commit.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MutationBaseline {
    /// Git commit SHA this baseline was created from.
    pub commit: String,
    /// ISO 8601 timestamp when the baseline was created.
    pub timestamp: String,
    /// Overall mutation score (0.0 to 1.0).
    pub overall_score: f64,
    /// Per-file mutation scores.
    pub file_scores: HashMap<String, f64>,
    /// Per-operator statistics.
    pub operator_stats: HashMap<String, OperatorScore>,
}

/// Mutation score statistics for a single operator.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OperatorScore {
    /// Total mutants generated by this operator.
    pub total: usize,
    /// Number of killed mutants.
    pub killed: usize,
    /// Mutation score for this operator (0.0 to 1.0).
    pub score: f64,
}

/// Comparison result between two baselines.
#[derive(Debug, Clone)]
pub struct BaselineComparison {
    /// Change in overall score (positive = improvement, negative = regression).
    pub score_delta: f64,
    /// Files that regressed (lower score than baseline).
    pub regressed_files: Vec<String>,
    /// Files that improved (higher score than baseline).
    pub improved_files: Vec<String>,
    /// New files not in baseline.
    pub new_files: Vec<String>,
    /// Files removed since baseline.
    pub removed_files: Vec<String>,
}

impl MutationBaseline {
    /// Create a new baseline from an analysis result.
    pub fn new(commit: &str, analysis: &Analysis) -> Self {
        let timestamp = chrono::Utc::now().to_rfc3339();

        let mut file_scores = HashMap::new();
        for file in &analysis.files {
            file_scores.insert(file.path.clone(), file.score);
        }

        let mut operator_stats = HashMap::new();
        for (name, stats) in &analysis.summary.by_operator {
            let score = if stats.total > 0 {
                stats.killed as f64 / stats.total as f64
            } else {
                0.0
            };
            operator_stats.insert(
                name.clone(),
                OperatorScore {
                    total: stats.total,
                    killed: stats.killed,
                    score,
                },
            );
        }

        Self {
            commit: commit.to_string(),
            timestamp,
            overall_score: analysis.summary.mutation_score,
            file_scores,
            operator_stats,
        }
    }

    /// Load a baseline from a JSON file.
    pub fn load(path: &Path) -> Result<Self> {
        let content = fs::read_to_string(path).map_err(|e| {
            Error::analysis(format!(
                "Failed to read baseline file {}: {}",
                path.display(),
                e
            ))
        })?;

        serde_json::from_str(&content).map_err(|e| {
            Error::analysis(format!(
                "Failed to parse baseline file {}: {}",
                path.display(),
                e
            ))
        })
    }

    /// Save this baseline to a JSON file.
    pub fn save(&self, path: &Path) -> Result<()> {
        // Ensure parent directory exists
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent).map_err(|e| {
                Error::analysis(format!(
                    "Failed to create directory {}: {}",
                    parent.display(),
                    e
                ))
            })?;
        }

        let content = serde_json::to_string_pretty(self)?;
        fs::write(path, content).map_err(|e| {
            Error::analysis(format!(
                "Failed to write baseline file {}: {}",
                path.display(),
                e
            ))
        })?;

        Ok(())
    }

    /// Compare this baseline against another baseline or analysis.
    pub fn compare(&self, other: &Self) -> BaselineComparison {
        let score_delta = other.overall_score - self.overall_score;

        let mut regressed_files = Vec::new();
        let mut improved_files = Vec::new();
        let mut new_files = Vec::new();

        for (file, &new_score) in &other.file_scores {
            match self.file_scores.get(file) {
                Some(&old_score) => {
                    let delta = new_score - old_score;
                    // Use a small epsilon for floating point comparison
                    if delta < -0.001 {
                        regressed_files.push(file.clone());
                    } else if delta > 0.001 {
                        improved_files.push(file.clone());
                    }
                }
                None => {
                    new_files.push(file.clone());
                }
            }
        }

        let removed_files: Vec<String> = self
            .file_scores
            .keys()
            .filter(|f| !other.file_scores.contains_key(*f))
            .cloned()
            .collect();

        BaselineComparison {
            score_delta,
            regressed_files,
            improved_files,
            new_files,
            removed_files,
        }
    }

    /// Check if the current score represents a regression below threshold.
    ///
    /// Returns true if `current_score` is lower than the baseline score minus the threshold.
    pub fn detect_regression(&self, current_score: f64, threshold: f64) -> bool {
        current_score < self.overall_score - threshold
    }
}

impl From<&OperatorStats> for OperatorScore {
    fn from(stats: &OperatorStats) -> Self {
        let score = if stats.total > 0 {
            stats.killed as f64 / stats.total as f64
        } else {
            0.0
        };
        Self {
            total: stats.total,
            killed: stats.killed,
            score,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::analyzers::mutation::{FileResult, Mutant, MutantStatus, MutationResult, Summary};

    fn create_test_analysis(score: f64, files: Vec<(&str, f64)>) -> Analysis {
        let mut by_operator = HashMap::new();
        by_operator.insert(
            "CRR".to_string(),
            OperatorStats {
                total: 10,
                killed: 8,
                survived: 2,
            },
        );

        let file_count = files.len();
        let file_results: Vec<FileResult> = files
            .into_iter()
            .map(|(path, file_score)| FileResult {
                path: path.to_string(),
                mutants: vec![MutationResult::new(
                    Mutant::new("1", path, "CRR", 1, 1, "1", "0", "desc", (0, 1)),
                    MutantStatus::Killed,
                    100,
                )],
                killed: 1,
                survived: 0,
                timeout: 0,
                error: 0,
                score: file_score,
            })
            .collect();

        Analysis {
            files: file_results,
            summary: Summary {
                total_files: file_count,
                total_mutants: 10,
                killed: 8,
                survived: 2,
                timeout: 0,
                error: 0,
                mutation_score: score,
                duration_ms: 1000,
                by_operator,
            },
        }
    }

    #[test]
    fn test_baseline_new_creates_from_analysis() {
        let analysis = create_test_analysis(0.8, vec![("src/main.rs", 0.9), ("src/lib.rs", 0.7)]);
        let baseline = MutationBaseline::new("abc123", &analysis);

        assert_eq!(baseline.commit, "abc123");
        assert!((baseline.overall_score - 0.8).abs() < f64::EPSILON);
        assert_eq!(baseline.file_scores.len(), 2);
        assert!((baseline.file_scores["src/main.rs"] - 0.9).abs() < f64::EPSILON);
        assert!((baseline.file_scores["src/lib.rs"] - 0.7).abs() < f64::EPSILON);
    }

    #[test]
    fn test_baseline_new_captures_operator_stats() {
        let analysis = create_test_analysis(0.8, vec![("src/main.rs", 0.8)]);
        let baseline = MutationBaseline::new("abc123", &analysis);

        assert!(baseline.operator_stats.contains_key("CRR"));
        let crr = &baseline.operator_stats["CRR"];
        assert_eq!(crr.total, 10);
        assert_eq!(crr.killed, 8);
        assert!((crr.score - 0.8).abs() < f64::EPSILON);
    }

    #[test]
    fn test_baseline_save_and_load_roundtrip() {
        let analysis = create_test_analysis(0.75, vec![("src/main.rs", 0.75)]);
        let baseline = MutationBaseline::new("def456", &analysis);

        let temp = tempfile::tempdir().unwrap();
        let path = temp.path().join("baseline.json");

        baseline.save(&path).unwrap();
        let loaded = MutationBaseline::load(&path).unwrap();

        assert_eq!(loaded.commit, baseline.commit);
        assert!((loaded.overall_score - baseline.overall_score).abs() < f64::EPSILON);
        assert_eq!(loaded.file_scores.len(), baseline.file_scores.len());
    }

    #[test]
    fn test_baseline_load_nonexistent_file() {
        let result = MutationBaseline::load(Path::new("/nonexistent/baseline.json"));
        assert!(result.is_err());
    }

    #[test]
    fn test_baseline_load_invalid_json() {
        let temp = tempfile::tempdir().unwrap();
        let path = temp.path().join("invalid.json");
        fs::write(&path, "not valid json").unwrap();

        let result = MutationBaseline::load(&path);
        assert!(result.is_err());
    }

    #[test]
    fn test_baseline_save_creates_parent_directories() {
        let analysis = create_test_analysis(0.8, vec![]);
        let baseline = MutationBaseline::new("abc123", &analysis);

        let temp = tempfile::tempdir().unwrap();
        let path = temp.path().join("nested").join("dir").join("baseline.json");

        baseline.save(&path).unwrap();
        assert!(path.exists());
    }

    #[test]
    fn test_compare_detects_regression() {
        let old_analysis = create_test_analysis(0.9, vec![("src/main.rs", 0.9)]);
        let old_baseline = MutationBaseline::new("old", &old_analysis);

        let new_analysis = create_test_analysis(0.7, vec![("src/main.rs", 0.7)]);
        let new_baseline = MutationBaseline::new("new", &new_analysis);

        let comparison = old_baseline.compare(&new_baseline);

        assert!((comparison.score_delta - (-0.2)).abs() < f64::EPSILON);
        assert!(comparison
            .regressed_files
            .contains(&"src/main.rs".to_string()));
        assert!(comparison.improved_files.is_empty());
    }

    #[test]
    fn test_compare_detects_improvement() {
        let old_analysis = create_test_analysis(0.7, vec![("src/main.rs", 0.7)]);
        let old_baseline = MutationBaseline::new("old", &old_analysis);

        let new_analysis = create_test_analysis(0.9, vec![("src/main.rs", 0.9)]);
        let new_baseline = MutationBaseline::new("new", &new_analysis);

        let comparison = old_baseline.compare(&new_baseline);

        assert!((comparison.score_delta - 0.2).abs() < f64::EPSILON);
        assert!(comparison
            .improved_files
            .contains(&"src/main.rs".to_string()));
        assert!(comparison.regressed_files.is_empty());
    }

    #[test]
    fn test_compare_detects_new_files() {
        let old_analysis = create_test_analysis(0.8, vec![("src/main.rs", 0.8)]);
        let old_baseline = MutationBaseline::new("old", &old_analysis);

        let new_analysis =
            create_test_analysis(0.8, vec![("src/main.rs", 0.8), ("src/new.rs", 0.9)]);
        let new_baseline = MutationBaseline::new("new", &new_analysis);

        let comparison = old_baseline.compare(&new_baseline);

        assert!(comparison.new_files.contains(&"src/new.rs".to_string()));
    }

    #[test]
    fn test_compare_detects_removed_files() {
        let old_analysis =
            create_test_analysis(0.8, vec![("src/main.rs", 0.8), ("src/old.rs", 0.7)]);
        let old_baseline = MutationBaseline::new("old", &old_analysis);

        let new_analysis = create_test_analysis(0.8, vec![("src/main.rs", 0.8)]);
        let new_baseline = MutationBaseline::new("new", &new_analysis);

        let comparison = old_baseline.compare(&new_baseline);

        assert!(comparison.removed_files.contains(&"src/old.rs".to_string()));
    }

    #[test]
    fn test_detect_regression_true_when_below_threshold() {
        let analysis = create_test_analysis(0.8, vec![]);
        let baseline = MutationBaseline::new("abc", &analysis);

        // Current score 0.6 is below baseline (0.8) minus threshold (0.1) = 0.7
        assert!(baseline.detect_regression(0.6, 0.1));
    }

    #[test]
    fn test_detect_regression_false_within_threshold() {
        let analysis = create_test_analysis(0.8, vec![]);
        let baseline = MutationBaseline::new("abc", &analysis);

        // Current score 0.75 is above baseline (0.8) minus threshold (0.1) = 0.7
        assert!(!baseline.detect_regression(0.75, 0.1));
    }

    #[test]
    fn test_detect_regression_false_when_improved() {
        let analysis = create_test_analysis(0.8, vec![]);
        let baseline = MutationBaseline::new("abc", &analysis);

        // Current score 0.9 is better than baseline
        assert!(!baseline.detect_regression(0.9, 0.1));
    }

    #[test]
    fn test_operator_score_from_stats() {
        let stats = OperatorStats {
            total: 20,
            killed: 15,
            survived: 5,
        };

        let score: OperatorScore = (&stats).into();

        assert_eq!(score.total, 20);
        assert_eq!(score.killed, 15);
        assert!((score.score - 0.75).abs() < f64::EPSILON);
    }

    #[test]
    fn test_operator_score_from_stats_zero_total() {
        let stats = OperatorStats {
            total: 0,
            killed: 0,
            survived: 0,
        };

        let score: OperatorScore = (&stats).into();

        assert_eq!(score.total, 0);
        assert_eq!(score.score, 0.0);
    }
}
