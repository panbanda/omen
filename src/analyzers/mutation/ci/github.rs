//! GitHub integration for mutation testing CI/CD.
//!
//! Formats mutation results for GitHub PRs and check runs.

use std::env;

use crate::core::{Error, Result};

use super::super::Analysis;

/// GitHub reporter for mutation testing results.
pub struct GitHubReporter {
    /// GitHub API token (from GITHUB_TOKEN env).
    token: Option<String>,
    /// Repository in owner/repo format.
    repo: String,
}

impl GitHubReporter {
    /// Create a new GitHub reporter from environment variables.
    ///
    /// Looks for:
    /// - `GITHUB_TOKEN` - API token for posting comments
    /// - `GITHUB_REPOSITORY` - Repository in owner/repo format
    ///
    /// Returns None if repository is not set.
    pub fn from_env() -> Option<Self> {
        let repo = env::var("GITHUB_REPOSITORY").ok()?;
        let token = env::var("GITHUB_TOKEN").ok();

        Some(Self { token, repo })
    }

    /// Create a new GitHub reporter with explicit values.
    pub fn new(repo: impl Into<String>, token: Option<String>) -> Self {
        Self {
            token,
            repo: repo.into(),
        }
    }

    /// Get the repository name.
    pub fn repo(&self) -> &str {
        &self.repo
    }

    /// Check if a token is available for API calls.
    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    /// Format mutation results as a PR comment in markdown.
    pub fn format_pr_comment(&self, analysis: &Analysis) -> String {
        let mut output = String::new();

        // Header with score
        let score_percent = analysis.summary.mutation_score * 100.0;
        let score_emoji = if score_percent >= 80.0 {
            "white_check_mark"
        } else if score_percent >= 60.0 {
            "warning"
        } else {
            "x"
        };

        output.push_str(&format!(
            "## :{}:  Mutation Testing Results\n\n",
            score_emoji
        ));

        // Summary table
        output.push_str("| Metric | Value |\n");
        output.push_str("|--------|-------|\n");
        output.push_str(&format!("| Mutation Score | **{:.1}%** |\n", score_percent));
        output.push_str(&format!(
            "| Total Mutants | {} |\n",
            analysis.summary.total_mutants
        ));
        output.push_str(&format!("| Killed | {} |\n", analysis.summary.killed));
        output.push_str(&format!("| Survived | {} |\n", analysis.summary.survived));
        output.push_str(&format!("| Timeout | {} |\n", analysis.summary.timeout));
        output.push_str(&format!(
            "| Duration | {:.1}s |\n",
            analysis.summary.duration_ms as f64 / 1000.0
        ));

        // Operator breakdown
        if !analysis.summary.by_operator.is_empty() {
            output.push_str("### By Operator\n\n");
            output.push_str("| Operator | Total | Killed | Survived | Score |\n");
            output.push_str("|----------|-------|--------|----------|-------|\n");

            let mut operators: Vec<_> = analysis.summary.by_operator.iter().collect();
            operators.sort_by_key(|(name, _)| *name);

            for (name, stats) in operators {
                let op_score = if stats.total > 0 {
                    stats.killed as f64 / stats.total as f64 * 100.0
                } else {
                    0.0
                };
                output.push_str(&format!(
                    "| {} | {} | {} | {} | {:.1}% |\n",
                    name, stats.total, stats.killed, stats.survived, op_score
                ));
            }
        }

        // Survived mutants summary (top 10)
        let survived: Vec<_> = analysis
            .files
            .iter()
            .flat_map(|f| &f.mutants)
            .filter(|m| m.status.is_survived())
            .take(10)
            .collect();

        if !survived.is_empty() {
            output.push_str("\n### Survived Mutants (Top 10)\n\n");
            output.push_str(
                "These mutants were not caught by tests and may indicate test coverage gaps:\n\n",
            );

            for result in survived {
                let m = &result.mutant;
                output.push_str(&format!(
                    "- **{}:{}** `{}` -> `{}` ({})\n",
                    m.file_path.display(),
                    m.line,
                    m.original,
                    m.replacement,
                    m.operator
                ));
            }
        }

        output.push_str("\n---\n");
        output.push_str("*Generated by omen mutation testing*\n");

        output
    }

    /// Format mutation results as GitHub check run output.
    pub fn format_check_output(&self, analysis: &Analysis) -> String {
        let mut output = String::new();

        let score_percent = analysis.summary.mutation_score * 100.0;

        output.push_str(&format!("Mutation Score: {:.1}%\n\n", score_percent));
        output.push_str(&format!(
            "Mutants: {} total, {} killed, {} survived, {} timeout\n",
            analysis.summary.total_mutants,
            analysis.summary.killed,
            analysis.summary.survived,
            analysis.summary.timeout
        ));

        // List files with poor scores
        let poor_files: Vec<_> = analysis
            .files
            .iter()
            .filter(|f| f.score < 0.6 && !f.mutants.is_empty())
            .collect();

        if !poor_files.is_empty() {
            output.push_str("\nFiles with low mutation scores (<60%):\n");
            for file in poor_files {
                output.push_str(&format!(
                    "  {} - {:.1}% ({}/{} killed)\n",
                    file.path,
                    file.score * 100.0,
                    file.killed,
                    file.mutants.len()
                ));
            }
        }

        output
    }

    /// Post a comment to a GitHub PR.
    ///
    /// Requires a valid token to be set.
    pub async fn post_pr_comment(&self, pr_number: u32, comment: &str) -> Result<()> {
        let token = self
            .token
            .as_ref()
            .ok_or_else(|| Error::analysis("GITHUB_TOKEN not set, cannot post PR comment"))?;

        let url = format!(
            "https://api.github.com/repos/{}/issues/{}/comments",
            self.repo, pr_number
        );

        let client = reqwest::Client::new();
        let response = client
            .post(&url)
            .header("Authorization", format!("Bearer {}", token))
            .header("Accept", "application/vnd.github.v3+json")
            .header("User-Agent", "omen-mutation-testing")
            .json(&serde_json::json!({ "body": comment }))
            .send()
            .await
            .map_err(|e| Error::analysis(format!("Failed to post PR comment: {}", e)))?;

        if !response.status().is_success() {
            let status = response.status();
            let body = response
                .text()
                .await
                .unwrap_or_else(|_| "unknown error".to_string());
            return Err(Error::analysis(format!(
                "GitHub API error ({}): {}",
                status, body
            )));
        }

        Ok(())
    }

    /// Update or create a check run.
    ///
    /// Requires a valid token with `checks:write` permission.
    pub async fn update_check_run(
        &self,
        check_run_id: Option<u64>,
        name: &str,
        conclusion: &str,
        title: &str,
        summary: &str,
    ) -> Result<u64> {
        let token = self
            .token
            .as_ref()
            .ok_or_else(|| Error::analysis("GITHUB_TOKEN not set, cannot update check run"))?;

        let client = reqwest::Client::new();

        let (url, method) = match check_run_id {
            Some(id) => (
                format!(
                    "https://api.github.com/repos/{}/check-runs/{}",
                    self.repo, id
                ),
                "PATCH",
            ),
            None => (
                format!("https://api.github.com/repos/{}/check-runs", self.repo),
                "POST",
            ),
        };

        let body = serde_json::json!({
            "name": name,
            "status": "completed",
            "conclusion": conclusion,
            "output": {
                "title": title,
                "summary": summary
            }
        });

        let request = if method == "PATCH" {
            client.patch(&url)
        } else {
            client.post(&url)
        };

        let response = request
            .header("Authorization", format!("Bearer {}", token))
            .header("Accept", "application/vnd.github.v3+json")
            .header("User-Agent", "omen-mutation-testing")
            .json(&body)
            .send()
            .await
            .map_err(|e| Error::analysis(format!("Failed to update check run: {}", e)))?;

        if !response.status().is_success() {
            let status = response.status();
            let body = response
                .text()
                .await
                .unwrap_or_else(|_| "unknown error".to_string());
            return Err(Error::analysis(format!(
                "GitHub API error ({}): {}",
                status, body
            )));
        }

        let response_body: serde_json::Value = response
            .json()
            .await
            .map_err(|e| Error::analysis(format!("Failed to parse response: {}", e)))?;

        response_body["id"]
            .as_u64()
            .ok_or_else(|| Error::analysis("Missing id in response"))
    }
}

/// Parse a GitHub Actions event to get the PR number.
pub fn get_pr_number_from_event() -> Option<u32> {
    let event_path = env::var("GITHUB_EVENT_PATH").ok()?;
    let content = std::fs::read_to_string(&event_path).ok()?;
    let event: serde_json::Value = serde_json::from_str(&content).ok()?;

    // Try pull_request.number first, then issue.number
    event["pull_request"]["number"]
        .as_u64()
        .or_else(|| event["issue"]["number"].as_u64())
        .map(|n| n as u32)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::analyzers::mutation::{
        FileResult, Mutant, MutantStatus, MutationResult, OperatorStats, Summary,
    };
    use std::collections::HashMap;

    fn create_test_analysis() -> Analysis {
        let mut by_operator = HashMap::new();
        by_operator.insert(
            "CRR".to_string(),
            OperatorStats {
                total: 10,
                killed: 7,
                survived: 3,
            },
        );
        by_operator.insert(
            "ROR".to_string(),
            OperatorStats {
                total: 5,
                killed: 5,
                survived: 0,
            },
        );

        Analysis {
            files: vec![
                FileResult {
                    path: "src/main.rs".to_string(),
                    mutants: vec![
                        MutationResult::new(
                            Mutant::new(
                                "1",
                                "src/main.rs",
                                "CRR",
                                10,
                                5,
                                "1",
                                "0",
                                "Replace 1 with 0",
                                (100, 101),
                            ),
                            MutantStatus::Killed,
                            100,
                        ),
                        MutationResult::new(
                            Mutant::new(
                                "2",
                                "src/main.rs",
                                "CRR",
                                15,
                                10,
                                "true",
                                "false",
                                "Replace true with false",
                                (200, 204),
                            ),
                            MutantStatus::Survived,
                            100,
                        ),
                    ],
                    killed: 1,
                    survived: 1,
                    timeout: 0,
                    error: 0,
                    skipped: 0,
                    score: 0.5,
                },
                FileResult {
                    path: "src/lib.rs".to_string(),
                    mutants: vec![MutationResult::new(
                        Mutant::new(
                            "3",
                            "src/lib.rs",
                            "ROR",
                            5,
                            3,
                            "<",
                            ">",
                            "Replace < with >",
                            (50, 51),
                        ),
                        MutantStatus::Killed,
                        100,
                    )],
                    killed: 1,
                    survived: 0,
                    timeout: 0,
                    error: 0,
                    skipped: 0,
                    score: 1.0,
                },
            ],
            summary: Summary {
                total_files: 2,
                total_mutants: 15,
                killed: 12,
                survived: 3,
                timeout: 0,
                error: 0,
                skipped: 0,
                mutation_score: 0.8,
                duration_ms: 5000,
                by_operator,
            },
        }
    }

    #[test]
    fn test_github_reporter_new() {
        let reporter = GitHubReporter::new("owner/repo", Some("token".to_string()));
        assert_eq!(reporter.repo(), "owner/repo");
        assert!(reporter.has_token());
    }

    #[test]
    fn test_github_reporter_no_token() {
        let reporter = GitHubReporter::new("owner/repo", None);
        assert!(!reporter.has_token());
    }

    #[test]
    fn test_format_pr_comment_includes_score() {
        let reporter = GitHubReporter::new("owner/repo", None);
        let analysis = create_test_analysis();

        let comment = reporter.format_pr_comment(&analysis);

        assert!(comment.contains("80.0%"));
        assert!(comment.contains("Mutation Testing Results"));
        assert!(comment.contains("| Mutation Score |"));
    }

    #[test]
    fn test_format_pr_comment_includes_summary_table() {
        let reporter = GitHubReporter::new("owner/repo", None);
        let analysis = create_test_analysis();

        let comment = reporter.format_pr_comment(&analysis);

        assert!(comment.contains("| Total Mutants | 15 |"));
        assert!(comment.contains("| Killed | 12 |"));
        assert!(comment.contains("| Survived | 3 |"));
    }

    #[test]
    fn test_format_pr_comment_includes_operators() {
        let reporter = GitHubReporter::new("owner/repo", None);
        let analysis = create_test_analysis();

        let comment = reporter.format_pr_comment(&analysis);

        assert!(comment.contains("By Operator"));
        assert!(comment.contains("| CRR |"));
        assert!(comment.contains("| ROR |"));
    }

    #[test]
    fn test_format_pr_comment_includes_survived_mutants() {
        let reporter = GitHubReporter::new("owner/repo", None);
        let analysis = create_test_analysis();

        let comment = reporter.format_pr_comment(&analysis);

        assert!(comment.contains("Survived Mutants"));
        assert!(comment.contains("true"));
        assert!(comment.contains("false"));
    }

    #[test]
    fn test_format_pr_comment_emoji_high_score() {
        let reporter = GitHubReporter::new("owner/repo", None);
        let analysis = create_test_analysis(); // 80% score

        let comment = reporter.format_pr_comment(&analysis);

        assert!(comment.contains("white_check_mark"));
    }

    #[test]
    fn test_format_pr_comment_emoji_low_score() {
        let reporter = GitHubReporter::new("owner/repo", None);
        let mut analysis = create_test_analysis();
        analysis.summary.mutation_score = 0.5;

        let comment = reporter.format_pr_comment(&analysis);

        assert!(comment.contains(":x:"));
    }

    #[test]
    fn test_format_check_output() {
        let reporter = GitHubReporter::new("owner/repo", None);
        let analysis = create_test_analysis();

        let output = reporter.format_check_output(&analysis);

        assert!(output.contains("Mutation Score: 80.0%"));
        assert!(output.contains("15 total"));
        assert!(output.contains("12 killed"));
    }

    #[test]
    fn test_format_check_output_poor_files() {
        let reporter = GitHubReporter::new("owner/repo", None);
        let analysis = create_test_analysis(); // main.rs has 50% score

        let output = reporter.format_check_output(&analysis);

        assert!(output.contains("Files with low mutation scores"));
        assert!(output.contains("src/main.rs"));
    }

    #[test]
    fn test_from_env_returns_none_without_repo() {
        // Clear any existing env vars
        env::remove_var("GITHUB_REPOSITORY");
        env::remove_var("GITHUB_TOKEN");

        let reporter = GitHubReporter::from_env();
        assert!(reporter.is_none());
    }

    #[test]
    fn test_from_env_works_with_repo() {
        env::set_var("GITHUB_REPOSITORY", "test/repo");
        env::set_var("GITHUB_TOKEN", "test-token");

        let reporter = GitHubReporter::from_env();
        assert!(reporter.is_some());

        let reporter = reporter.unwrap();
        assert_eq!(reporter.repo(), "test/repo");
        assert!(reporter.has_token());

        // Clean up
        env::remove_var("GITHUB_REPOSITORY");
        env::remove_var("GITHUB_TOKEN");
    }

    #[test]
    fn test_from_env_works_without_token() {
        env::set_var("GITHUB_REPOSITORY", "test/repo");
        env::remove_var("GITHUB_TOKEN");

        let reporter = GitHubReporter::from_env();
        assert!(reporter.is_some());
        assert!(!reporter.unwrap().has_token());

        // Clean up
        env::remove_var("GITHUB_REPOSITORY");
    }

    #[test]
    fn test_get_pr_number_returns_none_without_event() {
        env::remove_var("GITHUB_EVENT_PATH");
        let pr_number = get_pr_number_from_event();
        assert!(pr_number.is_none());
    }

    #[test]
    fn test_get_pr_number_from_event_file() {
        let temp = tempfile::tempdir().unwrap();
        let event_path = temp.path().join("event.json");
        std::fs::write(&event_path, r#"{"pull_request": {"number": 42}}"#).unwrap();

        env::set_var("GITHUB_EVENT_PATH", event_path.to_str().unwrap());

        let pr_number = get_pr_number_from_event();
        assert_eq!(pr_number, Some(42));

        env::remove_var("GITHUB_EVENT_PATH");
    }
}
