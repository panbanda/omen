# Omen CLI Configuration
# Copy this file to omen.toml or .omen/omen.toml

[analysis]
# Enable/disable specific analyzers when running `omen analyze` without subcommand
complexity = true
satd = true
dead_code = true
churn = true
duplicates = true
defect = true      # File-level defect probability (PMAT)
tdg = true
graph = true
lint_hotspot = true
context = true
churn_days = 90    # Days of git history to analyze
# max_file_size = 10485760  # Skip files larger than 10MB (0 = no limit)

[thresholds]
cyclomatic_complexity = 10
cognitive_complexity = 15
duplicate_min_lines = 6
duplicate_similarity = 0.8
dead_code_confidence = 0.8
defect_high_risk = 0.6
tdg_high_risk = 3.0

[exclude]
# Respect .gitignore files (default: true)
gitignore = true

# File patterns to exclude (glob patterns)
patterns = [
    "*_test.go",
    "*_test.ts",
    "*_test.py",
    "*.spec.ts",
    "*.spec.js",
    "*.min.js",
    "*.min.css",
    "*.generated.*",
]

# File extensions to exclude
extensions = [
    ".lock",
    ".sum",
    ".map",
]

# Directories to exclude
dirs = [
    "vendor",
    "node_modules",
    ".git",
    ".omen",
    "dist",
    "build",
    "target",
    "__pycache__",
    ".pytest_cache",
    "coverage",
]

[cache]
enabled = true
dir = ".omen/cache"
ttl = 24  # hours

[output]
format = "text"  # text, json, markdown, toon
color = true
verbose = false

[feature_flags]
# Providers to detect (empty = all)
# Available: launchdarkly, split, unleash, posthog, flipper
providers = []

[feature_flags.expected_ttl]
# Expected time-to-live for release flags (days)
release = 14
# Expected time-to-live for experiment flags (days)
experiment = 90

# Repository score settings
[score]
# Weights for composite score (must sum to 1.0)
[score.weights]
complexity = 0.25
duplication = 0.20
defect = 0.25
debt = 0.15
coupling = 0.10
smells = 0.05

# Minimum acceptable scores (0 = no enforcement)
[score.thresholds]
score = 0
complexity = 0
duplication = 0
defect = 0
debt = 0
coupling = 0
smells = 0

# Custom providers define tree-sitter queries for proprietary feature flag systems.
# Each custom provider needs:
#   - name: Provider identifier (used in --provider flag)
#   - languages: List of languages this query applies to (go, ruby, python, javascript, etc.)
#   - query: Tree-sitter query pattern with @flag_key capture for the flag identifier
#
# Example: Custom provider for a Ruby Feature class wrapping Flipper/PostHog
# [[feature_flags.custom_providers]]
# name = "feature"
# languages = ["ruby"]
# query = '''
# (call
#   receiver: (constant) @receiver
#   (#eq? @receiver "Feature")
#   method: (identifier) @method
#   (#match? @method "^(enabled\\?|get_feature_flag)$")
#   arguments: (argument_list
#     .
#     (simple_symbol) @flag_key))
# '''
