name: 'Omen Analysis'
description: 'Run diff risk analysis and health scoring on pull requests'
author: 'panbanda'

branding:
  icon: 'shield'
  color: 'purple'

inputs:
  version:
    description: 'Omen version to install (e.g. "4.20.3"). Defaults to latest release.'
    required: false
    default: 'latest'
  path:
    description: 'Repository path to analyze'
    required: false
    default: '.'
  comment:
    description: 'Post or update a sticky PR comment with analysis results'
    required: false
    default: 'false'
  label:
    description: 'Add a risk-level label to the PR'
    required: false
    default: 'false'
  label-template:
    description: 'Label name template. Use {{level}} for risk level replacement.'
    required: false
    default: 'risk: {{level}}'
  label-color-low:
    description: 'Hex color (without #) for the low risk label'
    required: false
    default: '0e8a16'
  label-color-medium:
    description: 'Hex color (without #) for the medium risk label'
    required: false
    default: 'fbca04'
  label-color-high:
    description: 'Hex color (without #) for the high risk label'
    required: false
    default: 'd93f0b'
  check:
    description: 'Fail the action if risk level meets or exceeds threshold'
    required: false
    default: 'false'
  check-threshold:
    description: 'Risk level threshold for check failure (low, medium, high)'
    required: false
    default: 'high'

outputs:
  risk-score:
    description: 'Diff risk score (0.0 - 1.0)'
    value: ${{ steps.diff.outputs.risk-score }}
  risk-level:
    description: 'Risk level (low, medium, high)'
    value: ${{ steps.diff.outputs.risk-level }}
  health-score:
    description: 'Repository health score (0 - 100)'
    value: ${{ steps.score.outputs.health-score }}
  health-grade:
    description: 'Health grade (A, B, C, D, F)'
    value: ${{ steps.score.outputs.health-grade }}
  diff-json:
    description: 'Full omen diff JSON output'
    value: ${{ steps.diff.outputs.diff-json }}
  score-json:
    description: 'Full omen score JSON output'
    value: ${{ steps.score.outputs.score-json }}

runs:
  using: 'composite'
  steps:
    - name: Install omen
      id: install
      uses: actions/github-script@v8
      env:
        INPUT_VERSION: ${{ inputs.version }}
        GITHUB_TOKEN: ${{ github.token }}
      with:
        script: |
          const fs = require('fs');

          const targets = {
            'Linux-X64': 'x86_64-unknown-linux-gnu',
            'Linux-ARM64': 'aarch64-unknown-linux-gnu',
            'macOS-X64': 'x86_64-apple-darwin',
            'macOS-ARM64': 'aarch64-apple-darwin',
          };
          const key = `${process.env.RUNNER_OS}-${process.env.RUNNER_ARCH}`;
          const target = targets[key];
          if (!target) {
            core.setFailed(`Unsupported platform: ${key}`);
            return;
          }

          let release;
          if (process.env.INPUT_VERSION === 'latest') {
            const { data: releases } = await github.rest.repos.listReleases({
              owner: 'panbanda',
              repo: 'omen',
              per_page: 20,
            });
            release = releases.find(r =>
              !r.prerelease && !r.draft && r.tag_name.startsWith('omen-v')
            );
            if (!release) {
              core.setFailed('Could not determine latest omen release');
              return;
            }
          } else {
            const { data } = await github.rest.repos.getReleaseByTag({
              owner: 'panbanda',
              repo: 'omen',
              tag: `omen-v${process.env.INPUT_VERSION}`,
            });
            release = data;
          }

          const version = release.tag_name.replace('omen-v', '');
          core.info(`Installing omen ${version} for ${target}`);

          const assetName = `omen_${version}_${target}.tar.gz`;
          const asset = release.assets.find(a => a.name === assetName);
          if (!asset) {
            core.setFailed(`Asset ${assetName} not found in release ${release.tag_name}`);
            return;
          }

          const response = await fetch(asset.url, {
            headers: {
              'Accept': 'application/octet-stream',
              'Authorization': `Bearer ${process.env.GITHUB_TOKEN}`,
              'X-GitHub-Api-Version': '2022-11-28',
            },
          });
          if (!response.ok) {
            core.setFailed(`Failed to download ${assetName}: ${response.status} ${response.statusText}`);
            return;
          }

          const installDir = `${process.env.RUNNER_TEMP}/omen-install`;
          await io.mkdirP(installDir);

          const tarPath = `${installDir}/${assetName}`;
          fs.writeFileSync(tarPath, Buffer.from(await response.arrayBuffer()));
          await exec.exec('tar', ['xzf', tarPath, '-C', installDir]);
          fs.chmodSync(`${installDir}/omen`, 0o755);
          core.addPath(installDir);

    - name: Run omen diff
      id: diff
      uses: actions/github-script@v8
      env:
        INPUT_PATH: ${{ inputs.path }}
        BASE_REF: ${{ github.event.pull_request.base.ref }}
      with:
        script: |
          const fs = require('fs');
          const args = ['-f', 'json', '-p', process.env.INPUT_PATH, 'diff'];
          if (process.env.BASE_REF) {
            args.push('--target', `origin/${process.env.BASE_REF}`);
          }

          const { stdout } = await exec.getExecOutput('omen', args);
          const diff = JSON.parse(stdout);

          core.setOutput('risk-score', String(diff.score));
          core.setOutput('risk-level', diff.level);

          const json = JSON.stringify(diff);
          if (json.length < 900000) {
            core.setOutput('diff-json', json);
          } else {
            const filePath = `${process.env.RUNNER_TEMP}/omen-diff.json`;
            fs.writeFileSync(filePath, json);
            core.warning(`diff-json output exceeds 900KB (${json.length} bytes), writing to file instead`);
            core.setOutput('diff-json', filePath);
          }

    - name: Run omen score
      id: score
      uses: actions/github-script@v8
      env:
        INPUT_PATH: ${{ inputs.path }}
      with:
        script: |
          const fs = require('fs');
          const { stdout } = await exec.getExecOutput('omen', [
            '-f', 'json', '-p', process.env.INPUT_PATH, 'score',
          ]);
          const score = JSON.parse(stdout);

          core.setOutput('health-score', String(score.overall_score));
          core.setOutput('health-grade', score.grade);

          const json = JSON.stringify(score);
          if (json.length < 900000) {
            core.setOutput('score-json', json);
          } else {
            const filePath = `${process.env.RUNNER_TEMP}/omen-score.json`;
            fs.writeFileSync(filePath, json);
            core.warning(`score-json output exceeds 900KB (${json.length} bytes), writing to file instead`);
            core.setOutput('score-json', filePath);
          }

    - name: Post sticky comment
      if: inputs.comment == 'true' && github.event_name == 'pull_request'
      uses: actions/github-script@v8
      env:
        DIFF_JSON: ${{ steps.diff.outputs.diff-json }}
        SCORE_JSON: ${{ steps.score.outputs.score-json }}
      with:
        script: |
          const fs = require('fs');

          function loadJson(input) {
            try {
              return JSON.parse(input);
            } catch {
              return JSON.parse(fs.readFileSync(input, 'utf8'));
            }
          }

          const diff = loadJson(process.env.DIFF_JSON);
          const score = loadJson(process.env.SCORE_JSON);
          const prNumber = context.payload.pull_request.number;

          const factorsTable = Object.entries(diff.factors)
            .sort((a, b) => b[1] - a[1])
            .map(([key, value]) => `| ${key} | ${String(value).slice(0, 6)} |`)
            .join('\n');

          const recommendations = diff.recommendations
            .map(r => `- ${r}`)
            .join('\n');

          const componentsTable = Object.entries(score.components)
            .sort((a, b) => b[1].weight - a[1].weight)
            .map(([key, comp]) => `| ${key} | ${Math.round(comp.score * 10) / 10} | ${comp.weight} |`)
            .join('\n');

          const tipConfig = {
            complexity: {
              threshold: 80,
              label: 'Complexity',
              command: 'omen complexity --sort cyclomatic',
              advice: 'Focus on functions with cyclomatic complexity > 10. Extract helper functions, replace nested conditionals with early returns, and use polymorphism instead of switch statements.',
            },
            duplication: {
              threshold: 70,
              label: 'Duplication',
              command: 'omen clones',
              advice: 'Look for Type-1 (exact) and Type-2 (renamed) clones. Extract shared logic into reusable functions or modules. Prioritize clones in high-churn files.',
            },
            cohesion: {
              threshold: 80,
              label: 'Cohesion',
              command: 'omen cohesion --sort lcom',
              advice: 'Classes with high LCOM (Lack of Cohesion) are doing too many unrelated things. Split them into focused classes where methods share instance variables.',
            },
            tdg: {
              threshold: 75,
              label: 'TDG',
              command: 'omen tdg --sort score',
              advice: 'Files with low TDG scores have compounding debt across multiple dimensions. Focus on files graded D or F -- they accumulate complexity, duplication, and coupling simultaneously.',
            },
            satd: {
              threshold: 80,
              label: 'Known Debt (SATD)',
              command: 'omen satd --sort severity',
              advice: 'Resolve high-severity items first (FIXME, BUG, SECURITY). Low-severity TODOs can be batch-addressed. Remove stale debt items that are no longer relevant.',
            },
            coupling: {
              threshold: 70,
              label: 'Coupling',
              command: 'omen graph && omen smells',
              advice: 'Break cyclic dependencies by introducing interfaces or extracting shared types. Reduce fan-out from hub modules by splitting responsibilities.',
            },
            smells: {
              threshold: 80,
              label: 'Architectural Smells',
              command: 'omen smells',
              advice: 'Address critical smells first (cyclic dependencies, god components). Hub modules with high fan-out should be split. Unstable modules that many others depend on need stabilization.',
            },
          };

          let agentTips = '';
          for (const [name, comp] of Object.entries(score.components)) {
            const tip = tipConfig[name];
            if (tip && comp.score < tip.threshold) {
              agentTips += `\n**${tip.label}** (score: ${comp.score}) -- needs attention\n\n\`\`\`bash\n${tip.command}\n\`\`\`\n\n${tip.advice}\n\n---\n\n`;
            }
          }
          if (!agentTips) {
            agentTips = 'All components are scoring well. No specific improvements needed.';
          }

          const body = `<!-- omen-analysis -->
          ## Omen Analysis

          ### Diff Risk

          | | |
          |---|---|
          | **Risk Score** | ${Math.round(diff.score * 100)}% |
          | **Risk Level** | ${diff.level.toUpperCase()} |
          | **Files Modified** | ${diff.files_modified} |
          | **Lines Added** | +${diff.lines_added} |
          | **Lines Deleted** | -${diff.lines_deleted} |
          | **Commits** | ${diff.commits} |

          <details>
          <summary>Risk Factors</summary>

          | Factor | Score |
          |--------|-------|
          ${factorsTable}

          </details>

          <details>
          <summary>Recommendations</summary>

          ${recommendations}

          </details>

          ### Repository Health

          | | |
          |---|---|
          | **Health Score** | ${score.overall_score} / 100 |
          | **Grade** | ${score.grade} |
          | **Files Analyzed** | ${score.summary.files_analyzed} |
          | **Critical Issues** | ${score.summary.critical_issues} |

          <details>
          <summary>Score Components</summary>

          | Component | Score | Weight |
          |-----------|-------|--------|
          ${componentsTable}

          </details>

          <details>
          <summary>Tips for AI agents</summary>

          Use these commands to investigate and improve low-scoring areas.

          **Run full analysis:**

          \`\`\`bash
          omen -f json score    # health score with component breakdown
          omen -f json diff     # PR risk analysis
          omen hotspot          # high-churn + high-complexity files
          \`\`\`

          ${agentTips}

          **General workflow for improving scores:**

          1. Run the relevant analyzer command to identify specific files
          2. Focus on the highest-weight components first (complexity 25%, duplication 20%, cohesion 15%, TDG 15%)
          3. Make targeted improvements -- small refactors that reduce complexity or eliminate duplication
          4. Re-run \`omen score\` to verify improvement

          </details>`;

          const comments = await github.paginate(github.rest.issues.listComments, {
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: prNumber,
          });
          const existing = comments.find(c => c.body.includes('<!-- omen-analysis -->'));

          if (existing) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: existing.id,
              body,
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body,
            });
          }

    - name: Manage risk label
      if: inputs.label == 'true' && github.event_name == 'pull_request'
      uses: actions/github-script@v8
      env:
        RISK_LEVEL: ${{ steps.diff.outputs.risk-level }}
        LABEL_TEMPLATE: ${{ inputs.label-template }}
        COLOR_LOW: ${{ inputs.label-color-low }}
        COLOR_MEDIUM: ${{ inputs.label-color-medium }}
        COLOR_HIGH: ${{ inputs.label-color-high }}
      with:
        script: |
          const riskLevel = process.env.RISK_LEVEL;
          const template = process.env.LABEL_TEMPLATE;
          const prNumber = context.payload.pull_request.number;
          const currentLabel = template.replace('{{level}}', riskLevel);

          const colors = {
            low: process.env.COLOR_LOW,
            medium: process.env.COLOR_MEDIUM,
            high: process.env.COLOR_HIGH,
          };
          const color = colors[riskLevel];
          if (!color) {
            core.setFailed(`Unexpected risk level: '${riskLevel}'`);
            return;
          }

          // Get current labels on the PR
          const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: prNumber,
          });
          const currentLabelNames = new Set(currentLabels.map(l => l.name));

          // Remove stale risk labels that are actually on the PR
          for (const level of ['low', 'medium', 'high']) {
            const label = template.replace('{{level}}', level);
            if (label !== currentLabel && currentLabelNames.has(label)) {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                name: label,
              });
            }
          }

          // Create or update label definition with correct color
          try {
            await github.rest.issues.createLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: currentLabel,
              color,
            });
          } catch (e) {
            if (e.status === 422) {
              await github.rest.issues.updateLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: currentLabel,
                color,
              });
            }
          }

          // Add label to PR
          await github.rest.issues.addLabels({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: prNumber,
            labels: [currentLabel],
          });

    - name: Check threshold
      if: inputs.check == 'true'
      uses: actions/github-script@v8
      env:
        RISK_LEVEL: ${{ steps.diff.outputs.risk-level }}
        THRESHOLD: ${{ inputs.check-threshold }}
      with:
        script: |
          const levels = { low: 1, medium: 2, high: 3 };
          const riskLevel = process.env.RISK_LEVEL;
          const threshold = process.env.THRESHOLD;
          const actual = levels[riskLevel];
          const limit = levels[threshold];

          if (!actual || !limit) {
            core.setFailed(`Invalid risk level '${riskLevel}' or threshold '${threshold}' (expected low|medium|high)`);
            return;
          }

          if (actual >= limit) {
            core.setFailed(`Risk level '${riskLevel}' meets or exceeds threshold '${threshold}'`);
          }
